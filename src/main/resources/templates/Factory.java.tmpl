package [(${project.packageName})];

import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.awssdk.services.dynamodb.model.*;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.StreamSupport;
import java.util.function.Function;

import static [(${project.packageName})].lib.*;

public class [(${project.factoryClass})] {

    private final DynamoDbClient client;

    public [(${project.factoryClass})](DynamoDbClient client) {
        this.client = client;
    }
[# th:each="table : ${project.tables}"]
    private static [(${table.javaClass})] __construct[(${table.javaClass})](Map<String, AttributeValue> map) {
        [(${table.javaClass})].Builder builder = [(${table.javaClass})].builder();
        [# th:insert="~{construct-object}"][/]
        var obj = builder.build();
        return obj;
    }

    /**
      * Atomically puts an item or overwrite it.
      */
    public [(${table.javaClass})] put[(${table.javaClass})]( [# th:insert="~{all-attributes-types}"][/], boolean atomic )
    {
        if ([(${table.partitionKey.attribute})] == null) {
            throw new NullPointerException("Partition key \"[(${table.partitionKey.name})]\" is null");
        }
        [# th:if="${table.hasSortKey}"]
        if ([(${item.table.sortKey.attribute})] == null) {
            throw new NullPointerException("Sort key \"[(${item.table.sortKey.name})]\" is null");
        }
        [/]

        Map<String, AttributeValue> map = new HashMap<>();
        [# th:insert="~{key}"][/]
[# th:each="attribute : ${table.attributes}"]
        if ([(${attribute.attribute})] != null) {
            [(${table.javaClass})].[(${attribute.helper})].contributeToMap(map, [(${attribute.attribute})]);
        }
[/]
        var builder = PutItemRequest.builder()
                            .tableName("[(${table.name})]")
                            .item(map);
        if (atomic) {
            builder.conditionExpression("[(${table.putConditionExpression})]");
            builder.returnValuesOnConditionCheckFailure(ReturnValuesOnConditionCheckFailure.ALL_OLD);
        } else {
            builder.returnValues(ReturnValue.ALL_OLD);
        }

        try {
            var response = client.putItem(builder.build());
            if (response.hasAttributes() && !atomic) {
                map.putAll(response.attributes());
            }
            var obj = __construct[(${table.javaClass})](map);
            obj._setClient(client);
            return obj;
        } catch (ConditionalCheckFailedException e) {
          if (e.hasItem() && atomic){
              var previousObject = __construct[(${table.javaClass})](e.item());
              previousObject._setClient(client);
              return previousObject;
          } else {
              throw e;
          }
      }


    }

     public Optional<[(${table.javaClass})]> query[(${table.javaClass})]( [# th:insert="~{key-attributes-types}"][/] )
     {
        Map<String, AttributeValue> map = new HashMap<String, AttributeValue>();
        [# th:insert="~{key}"][/]

        GetItemRequest getItemRequest = GetItemRequest.builder()
                                            .tableName("[(${table.name})]")
                                            .key(map)
                                        .build();

        GetItemResponse result = client.getItem(getItemRequest);

        if (result.item().isEmpty()) {
            return Optional.empty();
        }
        map = result.item();
        var obj = __construct[(${table.javaClass})](map);
        obj._setClient(client);
        return Optional.of(obj);
     }

     public abstract class [(${table.javaClass})]Query {
        private final QueryRequest.Builder builder;
        protected final Map<String, Condition> keyConditions;
        protected final Map<String, Condition> queryFilter;

        private [(${table.javaClass})]Query() {
            this.builder = QueryRequest.builder();
            this.keyConditions = new LinkedHashMap<>();
            this.queryFilter = new LinkedHashMap<>();
        }

        private void _setTableName(String tableName) {
            this.builder.tableName(tableName);
        }

        private void _setIndexName(String indexName) {
            this.builder.indexName(indexName);
        }

        protected abstract Map<String, Condition> selectMapForAttribute(String attribute);

[# th:each="attribute : ${table.attributes}"]
        public lib.GenericQuery<[(${attribute.javaType})],[(${table.javaClass})]Query> [(${attribute.attribute})]() {
            return new lib.GenericQuery<>("[(${attribute.name})]", this, [(${table.javaClass})].[(${attribute.helper})], selectMapForAttribute("[(${attribute.name})]"));
        }
[/]
        public java.util.stream.Stream<[(${table.javaClass})]> execute() {
            if (!keyConditions.isEmpty()) {
                builder.keyConditions(keyConditions);
            }
            if (!queryFilter.isEmpty()) {
                builder.queryFilter(queryFilter);
            }
            var iterator = execute[(${table.javaClass})]Query(builder.build());
            var split = Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL);
            return StreamSupport.stream(split, false);
        }
     }

     public [(${table.javaClass})]Query query[(${table.javaClass})]By[(${#strings.capitalizeWords(table.partitionKey.attribute)})]([(${table.partitionKey.javaType})] [(${table.partitionKey.attribute})]) {
        [(${table.javaClass})]Query query = new [(${table.javaClass})]Query(){

            @Override
            protected Map<String, Condition> selectMapForAttribute(String attribute) {
                return switch (attribute) {
                    case "fix_me" -> keyConditions;
                [# th:each="attribute : ${table.attributes}"]
                    // case "[(${attribute.name})]" -> keyConditions;
                [/]
                [# th:each="attribute : ${table.attributes}"]
                    // case "[(${attribute.name})]" -> queryFilter;
                [/]
                    default -> throw new IllegalArgumentException("Unknown attribute '" + attribute + "'");
                };
            }
        };
        query._setTableName("[(${table.name})]");
        query.[(${table.partitionKey.attribute})]().eq([(${table.partitionKey.attribute})]);
        return query;
     }



     public java.util.stream.Stream<[(${table.javaClass})]> scanAll[(${table.javaClass})]() {
        var iterator = execute[(${table.javaClass})]Scan(ScanRequest.builder().tableName("[(${table.name})]").build());
        var split = Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL);
        return StreamSupport.stream(split, false);
     }

     private Iterator<[(${table.javaClass})]> execute[(${table.javaClass})]Query(QueryRequest queryRequest){
        AtomicReference<QueryResponse> currentResponse = new AtomicReference<>(client.query(queryRequest));
        AtomicReference<Iterator<Map<String, AttributeValue>>> currentIterator = new AtomicReference<>(currentResponse.get().items().iterator());
        return new Iterator<>() {
            @Override
            public boolean hasNext() {
                if (currentIterator.get().hasNext()) {
                    return true;
                } else {
                    if (currentResponse.get().hasLastEvaluatedKey()) {
                        Map<String, AttributeValue> lastEvaluatedKey = currentResponse.get().lastEvaluatedKey();
                        QueryRequest copy = queryRequest.copy(builder -> builder.exclusiveStartKey(lastEvaluatedKey));
                        currentResponse.set(client.query(copy));
                        currentIterator.set(currentResponse.get().items().iterator());
                        return true;
                    } else {
                        return false;
                    }
                }
            }

            @Override
            public [(${table.javaClass})] next() {
                Map<String, AttributeValue> map = currentIterator.get().next();
                var obj = __construct[(${table.javaClass})](map);
                obj._setClient(client);
                return obj;
            }
        };
     }

     private Iterator<[(${table.javaClass})]> execute[(${table.javaClass})]Scan(ScanRequest scanRequest) {
        AtomicReference<ScanResponse> currentResponse = new AtomicReference<>(client.scan(scanRequest));
        AtomicReference<Iterator<Map<String, AttributeValue>>> currentIterator = new AtomicReference<>(
                currentResponse.get().items().iterator());
        return new Iterator<>() {
            @Override
            public boolean hasNext() {
                if (currentIterator.get().hasNext()) {
                    return true;
                } else {
                    if (currentResponse.get().hasLastEvaluatedKey()) {
                        Map<String, AttributeValue> lastEvaluatedKey = currentResponse.get().lastEvaluatedKey();
                        ScanRequest copy = scanRequest.copy(builder -> builder.exclusiveStartKey(lastEvaluatedKey));
                        currentResponse.set(client.scan(copy));
                        currentIterator.set(currentResponse.get().items().iterator());
                        return true;
                    } else {
                        return false;
                    }
                }
            }

            @Override
            public [(${table.javaClass})] next() {
                Map<String, AttributeValue> map = currentIterator.get().next();
                var obj = __construct[(${table.javaClass})](map);
                obj._setClient(client);
                return obj;
            }
        };
    }

[/]


}