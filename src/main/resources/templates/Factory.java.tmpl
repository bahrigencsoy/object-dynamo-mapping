package [(${project.packageName})];

import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.awssdk.services.dynamodb.model.*;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.StreamSupport;

import static [(${project.packageName})].lib.*;

public class [(${project.factoryClass})] {

    private final DynamoDbClient client;

    public [(${project.factoryClass})](DynamoDbClient client) {
        this.client = client;
    }
[# th:each="item : ${project.allItems}"]
    private static [(${item.name})] __construct[(${item.name})](Map<String, AttributeValue> map) {
        [(${item.name})].Builder builder = [(${item.name})].builder();
        [# th:insert="~{construct-object}"][/]
        var obj = builder.build();
        return obj;
    }

    public [(${item.name})] put[(${item.name})]( [# th:insert="~{all-attributes-types}"][/] )
    {
        if ([(${item.table.partitionKey.attribute})] == null) {
            throw new NullPointerException("Partition key \"[(${item.table.partitionKey.name})]\" is null");
        }
        [# th:if="${item.table.hasSortKey}"]
        if ([(${item.table.sortKey.attribute})] == null) {
            throw new NullPointerException("Sort key \"[(${item.table.sortKey.name})]\" is null");
        }
        [/]

        Map<String, AttributeValue> map = new HashMap<>();
        [# th:insert="~{key}"][/]
[# th:each="attribute : ${item.derivedAttributes}"]
        if ([(${attribute.attribute})] != null) {
            [(${item.name})].[(${attribute.helper})].contributeToMap(map, [(${attribute.attribute})]);
        }
[/]
        PutItemRequest putItemRequest = PutItemRequest.builder()
                            .tableName("[(${item.table.name})]")
                            .item(map)
                            .returnValues(ReturnValue.ALL_OLD)
                            .build();
        var response = client.putItem(putItemRequest);
        if (response.hasAttributes()) {
            // FIXME this means that there was a previous object with same key
            // don't know what to do
            var previousObject = __construct[(${item.name})](response.attributes());
        }
        var obj = __construct[(${item.name})](map);
        obj._setClient(client);
        return obj;
    }

     public Optional<[(${item.name})]> query[(${item.name})]( [# th:insert="~{key-attributes-types}"][/] )
     {
        Map<String, AttributeValue> map = new HashMap<String, AttributeValue>();
        [# th:insert="~{key}"][/]

        GetItemRequest getItemRequest = GetItemRequest.builder()
                                            .tableName("[(${item.table.name})]")
                                            .key(map)
                                        .build();

        GetItemResponse result = client.getItem(getItemRequest);

        if (result.item().isEmpty()) {
            return Optional.empty();
        }
        map = result.item();
        var obj = __construct[(${item.name})](map);
        obj._setClient(client);
        return Optional.of(obj);
     }

     public class [(${item.name})]Query {
        private final QueryRequest.Builder builder;
        private final Map<String, Condition> keyConditions;
        private final Map<String, Condition> queryFilter;

        private [(${item.name})]Query() {
            this.builder = QueryRequest.builder().tableName("[(${item.table.name})]");
            this.keyConditions = new LinkedHashMap<>();
            this.queryFilter = new LinkedHashMap<>();
        }

[# th:each="attribute : ${item.table.keyAttributes}"]
        public lib.GenericQuery<[(${attribute.javaType})],[(${item.name})]Query> [(${attribute.attribute})]() {
            return new lib.GenericQuery<>("[(${attribute.name})]", this, [(${item.name})].[(${attribute.helper})], keyConditions);
        }
[/]
[# th:each="attribute : ${item.derivedAttributes}"]
        public lib.GenericQuery<[(${attribute.javaType})],[(${item.name})]Query> [(${attribute.attribute})]() {
            return new lib.GenericQuery<>("[(${attribute.name})]", this, [(${item.name})].[(${attribute.helper})], queryFilter);
        }
[/]
        public java.util.stream.Stream<[(${item.name})]> execute() {
            if (!keyConditions.isEmpty()) {
                builder.keyConditions(keyConditions);
            }
            if (!queryFilter.isEmpty()) {
                builder.queryFilter(queryFilter);
            }
            var iterator = execute[(${item.name})]Query(builder.build());
            var split = Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL);
            return StreamSupport.stream(split, false);
        }
     }

     public [(${item.name})]Query query[(${item.name})]() {
        return new [(${item.name})]Query();
     }

     private Iterator<[(${item.name})]> execute[(${item.name})]Query(QueryRequest queryRequest){
        AtomicReference<QueryResponse> currentResponse = new AtomicReference<>(client.query(queryRequest));
        AtomicReference<Iterator<Map<String, AttributeValue>>> currentIterator = new AtomicReference<>(currentResponse.get().items().iterator());
        return new Iterator<>() {
            @Override
            public boolean hasNext() {
                if (currentIterator.get().hasNext()) {
                    return true;
                } else {
                    if (currentResponse.get().hasLastEvaluatedKey()) {
                        Map<String, AttributeValue> lastEvaluatedKey = currentResponse.get().lastEvaluatedKey();
                        QueryRequest copy = queryRequest.copy(builder -> builder.exclusiveStartKey(lastEvaluatedKey));
                        currentResponse.set(client.query(copy));
                        currentIterator.set(currentResponse.get().items().iterator());
                        return true;
                    } else {
                        return false;
                    }
                }
            }

            @Override
            public [(${item.name})] next() {
                Map<String, AttributeValue> map = currentIterator.get().next();
                var obj = __construct[(${item.name})](map);
                obj._setClient(client);
                return obj;
            }
        };
     }
[/]



public class DynamoDbQueryExample {

        public static void main(String[] args) {
            DynamoDbClient ddb = DynamoDbClient.create();

            String tableName = "YourTableName";
            String indexName = "Your-Secondary-Index-Name";
            String partitionKeyAlias = ":pkVal";

            // 1. Define the value you are searching for (e.g., searching for "user_123")
            Map<String, AttributeValue> expressionAttributeValues = new HashMap<>();
            expressionAttributeValues.put(partitionKeyAlias, AttributeValue.builder().s("user_123").build());

            // 2. Build the Query Request
            QueryRequest queryRequest = QueryRequest.builder()
                    .tableName(tableName)
                    .indexName(indexName) // <--- CRITICAL: Specify the index name here
                    .keyConditionExpression("IndexPartitionKeyName = " + partitionKeyAlias) // Use the index's key name
                    .expressionAttributeValues(expressionAttributeValues)
                    .build();

            // 3. Execute the Query
            QueryResponse response = ddb.query(queryRequest);

            // 4. Process results
            response.items().forEach(item -> {
                System.out.println("Item found: " + item);
            });
        }
    }
}