package [(${project.packageName})];

import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.awssdk.services.dynamodb.model.*;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.StreamSupport;
import java.util.function.Function;

import static [(${project.packageName})].lib.*;

public class [(${project.factoryClass})] {

    private final DynamoDbClient client;

    public [(${project.factoryClass})](DynamoDbClient client) {
        this.client = client;
    }
[# th:each="item : ${project.allItems}"]
    private static [(${item.name})] __construct[(${item.name})](Map<String, AttributeValue> map) {
        [(${item.name})].Builder builder = [(${item.name})].builder();
        [# th:insert="~{construct-object}"][/]
        var obj = builder.build();
        return obj;
    }

    /**
      * Atomically puts an item or overwrite it.
      */
    public [(${item.name})] put[(${item.name})]( [# th:insert="~{all-attributes-types}"][/], boolean atomic )
    {
        if ([(${item.table.partitionKey.attribute})] == null) {
            throw new NullPointerException("Partition key \"[(${item.table.partitionKey.name})]\" is null");
        }
        [# th:if="${item.table.hasSortKey}"]
        if ([(${item.table.sortKey.attribute})] == null) {
            throw new NullPointerException("Sort key \"[(${item.table.sortKey.name})]\" is null");
        }
        [/]

        Map<String, AttributeValue> map = new HashMap<>();
        [# th:insert="~{key}"][/]
[# th:each="attribute : ${item.derivedAttributes}"]
        if ([(${attribute.attribute})] != null) {
            [(${item.name})].[(${attribute.helper})].contributeToMap(map, [(${attribute.attribute})]);
        }
[/]
        var builder = PutItemRequest.builder()
                            .tableName("[(${item.table.name})]")
                            .item(map);
        if (atomic) {
            builder.conditionExpression("[(${item.table.putConditionExpression})]");
            builder.returnValuesOnConditionCheckFailure(ReturnValuesOnConditionCheckFailure.ALL_OLD);
        } else {
            builder.returnValues(ReturnValue.ALL_OLD);
        }

        try {
            var response = client.putItem(builder.build());
            if (response.hasAttributes() && !atomic) {
                map.putAll(response.attributes());
            }
            var obj = __construct[(${item.name})](map);
            obj._setClient(client);
            return obj;
        } catch (ConditionalCheckFailedException e) {
          if (e.hasItem() && atomic){
              var previousObject = __construct[(${item.name})](e.item());
              previousObject._setClient(client);
              return previousObject;
          } else {
              throw e;
          }
      }


    }

     public Optional<[(${item.name})]> query[(${item.name})]( [# th:insert="~{key-attributes-types}"][/] )
     {
        Map<String, AttributeValue> map = new HashMap<String, AttributeValue>();
        [# th:insert="~{key}"][/]

        GetItemRequest getItemRequest = GetItemRequest.builder()
                                            .tableName("[(${item.table.name})]")
                                            .key(map)
                                        .build();

        GetItemResponse result = client.getItem(getItemRequest);

        if (result.item().isEmpty()) {
            return Optional.empty();
        }
        map = result.item();
        var obj = __construct[(${item.name})](map);
        obj._setClient(client);
        return Optional.of(obj);
     }

     public abstract class [(${item.name})]Query {
        private final QueryRequest.Builder builder;
        protected final Map<String, Condition> keyConditions;
        protected final Map<String, Condition> queryFilter;

        private [(${item.name})]Query() {
            this.builder = QueryRequest.builder();
            this.keyConditions = new LinkedHashMap<>();
            this.queryFilter = new LinkedHashMap<>();
        }

        private void _setTableName(String tableName) {
            this.builder.tableName(tableName);
        }

        private void _setIndexName(String indexName) {
            this.builder.indexName(indexName);
        }

        protected abstract Map<String, Condition> selectMapForAttribute(String attribute);

[# th:each="attribute : ${item.allAttributes}"]
        public lib.GenericQuery<[(${attribute.javaType})],[(${item.name})]Query> [(${attribute.attribute})]() {
            return new lib.GenericQuery<>("[(${attribute.name})]", this, [(${item.name})].[(${attribute.helper})], selectMapForAttribute("[(${attribute.name})]"));
        }
[/]
        public java.util.stream.Stream<[(${item.name})]> execute() {
            if (!keyConditions.isEmpty()) {
                builder.keyConditions(keyConditions);
            }
            if (!queryFilter.isEmpty()) {
                builder.queryFilter(queryFilter);
            }
            var iterator = execute[(${item.name})]Query(builder.build());
            var split = Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL);
            return StreamSupport.stream(split, false);
        }
     }

     public [(${item.name})]Query query[(${item.name})]By[(${#strings.capitalizeWords(item.table.partitionKey.attribute)})]([(${item.table.partitionKey.javaType})] [(${item.table.partitionKey.attribute})]) {
        [(${item.name})]Query query = new [(${item.name})]Query(){

            @Override
            protected Map<String, Condition> selectMapForAttribute(String attribute) {
                return switch (attribute) {
                [# th:each="attribute : ${item.table.keyAttributes}"]
                    case "[(${attribute.name})]" -> keyConditions;
                [/]
                [# th:each="attribute : ${item.derivedAttributes}"]
                    case "[(${attribute.name})]" -> queryFilter;
                [/]
                    default -> throw new IllegalArgumentException("Unknown attribute '" + attribute + "'");
                };
            }
        };

        query._setTableName("[(${item.table.name})]");
        query.[(${item.table.partitionKey.attribute})]().eq([(${item.table.partitionKey.attribute})]);
        return query;
     }

     public java.util.stream.Stream<[(${item.name})]> scanAll[(${item.name})]() {
        var iterator = execute[(${item.name})]Scan(ScanRequest.builder().tableName("[(${item.table.name})]").build());
        var split = Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL);
        return StreamSupport.stream(split, false);
     }

     private Iterator<[(${item.name})]> execute[(${item.name})]Query(QueryRequest queryRequest){
        AtomicReference<QueryResponse> currentResponse = new AtomicReference<>(client.query(queryRequest));
        AtomicReference<Iterator<Map<String, AttributeValue>>> currentIterator = new AtomicReference<>(currentResponse.get().items().iterator());
        return new Iterator<>() {
            @Override
            public boolean hasNext() {
                if (currentIterator.get().hasNext()) {
                    return true;
                } else {
                    if (currentResponse.get().hasLastEvaluatedKey()) {
                        Map<String, AttributeValue> lastEvaluatedKey = currentResponse.get().lastEvaluatedKey();
                        QueryRequest copy = queryRequest.copy(builder -> builder.exclusiveStartKey(lastEvaluatedKey));
                        currentResponse.set(client.query(copy));
                        currentIterator.set(currentResponse.get().items().iterator());
                        return true;
                    } else {
                        return false;
                    }
                }
            }

            @Override
            public [(${item.name})] next() {
                Map<String, AttributeValue> map = currentIterator.get().next();
                var obj = __construct[(${item.name})](map);
                obj._setClient(client);
                return obj;
            }
        };
     }

     private Iterator<[(${item.name})]> execute[(${item.name})]Scan(ScanRequest scanRequest) {
        AtomicReference<ScanResponse> currentResponse = new AtomicReference<>(client.scan(scanRequest));
        AtomicReference<Iterator<Map<String, AttributeValue>>> currentIterator = new AtomicReference<>(
                currentResponse.get().items().iterator());
        return new Iterator<>() {
            @Override
            public boolean hasNext() {
                if (currentIterator.get().hasNext()) {
                    return true;
                } else {
                    if (currentResponse.get().hasLastEvaluatedKey()) {
                        Map<String, AttributeValue> lastEvaluatedKey = currentResponse.get().lastEvaluatedKey();
                        ScanRequest copy = scanRequest.copy(builder -> builder.exclusiveStartKey(lastEvaluatedKey));
                        currentResponse.set(client.scan(copy));
                        currentIterator.set(currentResponse.get().items().iterator());
                        return true;
                    } else {
                        return false;
                    }
                }
            }

            @Override
            public [(${item.name})] next() {
                Map<String, AttributeValue> map = currentIterator.get().next();
                var obj = __construct[(${item.name})](map);
                obj._setClient(client);
                return obj;
            }
        };
    }
[/]


}